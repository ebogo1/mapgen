<html>
        <head>
          <meta charset=utf-8>
          <title>mapgen</title>
          <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
          </style>
        </head>
        <body>
          <script src="js/build/three.js"></script>
          <script src="js/controls/OrbitControls.js"></script>
          <script src="js/loaders/OBJLoader.js"></script>
          <script src="js/src/WorldGrid.js"></script>
          <script>
            var camera, scene, container, renderer;
            var world, dim, groundDepth;
            var plight, alight, cube;

            var mouse, controls, raycaster;
            var isShiftDown = false;

            var targetGeo, targetMat, targetMesh;
            var gridGeo, gridMat, groundMat;
            var lambertMat;

            var objLoader;

            var voxels = [], tiles = [];

            init();
            render();

            function init() {
              scene = new THREE.Scene();
              container = new THREE.Group();
              dim = new THREE.Vector3(4,6,4);

              var viewSize = 12;
              var WIDTH = window.innerWidth;
              var HEIGHT = window.innerHeight;
              var aspectRatio = WIDTH / HEIGHT;
              //camera = new THREE.OrthographicCamera(-aspectRatio * viewSize / 2, aspectRatio * viewSize / 2, viewSize / 2, -viewSize / 2, -600, 600);
              camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
              scene.add(camera);
              camera.position.set(-12, 8, -6);

              // Create a renderer and add it to the DOM.
              renderer = new THREE.WebGLRenderer({antialias:true});
              renderer.setSize(WIDTH, HEIGHT);
              document.body.appendChild(renderer.domElement);

              mouse = new THREE.Vector2();
              controls = new THREE.OrbitControls(camera);
              raycaster = new THREE.Raycaster();

              // Create event listeners for mouse and keyboard inputs.
              document.addEventListener('mousemove', onDocumentMouseMove, false);
              document.addEventListener('mousedown', onDocumentMouseDown, false);
              document.addEventListener('keydown', onDocumentKeyDown, false);
              document.addEventListener('keyup', onDocumentKeyUp, false);
              // Create an event listener that resizes the renderer with the browser window.
              window.addEventListener('resize', function() {
                var WIDTH = window.innerWidth,
                    HEIGHT = window.innerHeight,
                    aspectRatio = WIDTH / HEIGHT;

                renderer.setSize(WIDTH, HEIGHT);
                camera.aspect = window.innerWidth / window.innerHeight;
                /* Commented out code used for othographic camera */
                // camera.left = -aspectRatio * viewSize / 2;
                // camera.right = aspectRatio * viewSize / 2;
                // camera.top = viewSize / 2;
                // camera.bottom = -viewSize / 2;
                camera.updateProjectionMatrix();
              });

              // Set the background color of the scene.
              var clearColor = new THREE.Color(0x6084fa);
              renderer.setClearColor(clearColor, 1);

              // Set up cube attributes
              gridMat = new THREE.MeshBasicMaterial( { color: 0xffffff } );
              gridMat.visible = false;
              gridGeo = new THREE.BoxGeometry(1, 1, 1);
              gridGeo.computeFaceNormals();

              groundMat = new THREE.MeshLambertMaterial( {color:0x503412} );
              lambertMat = new THREE.MeshLambertMaterial( {color:0xffffff} );

              // Add lights to the scene
              plight = new THREE.DirectionalLight(0xffffff, 1, 100);
              plight.position.set(12,20,8);
              slight = new THREE.DirectionalLight(0xffffff, .25, 100);
              slight.position.set(-4,20,-16);
              scene.add(plight);
              scene.add(slight);
              alight = new THREE.AmbientLight( 0xffffff, 0.35 );
              scene.add(alight);

              // Add rollover geometry to the scene
              targetGeo = new THREE.PlaneGeometry(1, 1);
              targetMat = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true, side: THREE.DoubleSide } );
              targetMesh = new THREE.Mesh(targetGeo, targetMat);
              targetMesh.visible = false;
              container.add(targetMesh);

              loadObjs();
              groundDepth = 0.5;
              setTimeout(loadWorld, 10, dim);
              setTimeout(loadGround, 100);
              container.position.y += groundDepth/2;
              container.position.x -= dim.x/2 - 0.5;
              container.position.y -= dim.y/2 - 0.5;
              container.position.z -= dim.z/2 - 0.5;
              scene.add(container);

            }

            function loadObjs() {
              objLoader = new THREE.OBJLoader();
              objLoader.load('obj/cube.obj',
                function(object) {
                  object.children[0].material = lambertMat;
                  tiles[0] = object;
                }
              );
              objLoader.load('obj/roof.obj',
                function(object) {
                  object.children[0].material = lambertMat;
                  tiles[1] = object;
                }
              );
            }

            function loadWorld(dim) {
              // Draw from world
              world = new WorldGrid(dim.x, dim.y, dim.z);
              for(var x = 0; x < world.x; x++) {
                for(var y = 0; y < world.y; y++) {
                  for(var z = 0; z < world.z; z++) {
                    if(world.grid[x][y][z] == 1) {
                      cube = new THREE.Mesh(gridGeo, gridMat);
                      cube.position.set(x,y,z);
                      container.add(cube);
                      voxels.push(cube);
                    }
                  }
                }
              }
            }

            function loadGround() {
              var y = -0.5 - groundDepth/2;
              for(var x = 0; x < world.x; x++) {
                for(var z = 0; z < world.z; z++) {
                  cube = new THREE.Mesh(gridGeo, groundMat);
                  cube.scale.y = .5;
                  cube.position.set(x,y,z);
                  container.add(cube);
                  voxels.push(cube);
                }
              }
            }

            function updateNeighbors(tilePos) {
              // Update surrounding tiles
              var xmin = Math.max(tilePos.x - 1, 0), xmax = Math.min(tilePos.x + 1, world.x - 1);
              var ymin = Math.max(tilePos.y - 1, 0), ymax = Math.min(tilePos.y + 1, world.y - 1);
              var zmin = Math.max(tilePos.z - 1, 0), zmax = Math.min(tilePos.z + 1, world.z - 1);
              for(var x = xmin; x <= xmax; x++) {
                for(var y = ymin; y <= ymax; y++) {
                  for(var z = zmin; z <= zmax; z++) {
                    if(world.grid[x][y][z] != 0 && world.getBlockType(x, y, z) != world.types[x][y][z]) {
                      var checkPos = new THREE.Vector3(x, y, z);
                      // Remove outdated tile
                      container.remove(container.getObjectByName(checkPos.toArray().toString().concat("t")));
                      // Add updated tile
                      var newTile = tiles[world.getBlockType(x,y,z)].clone();
                      newTile.position.copy(checkPos);
                      newTile.name = checkPos.toArray().toString().concat("t");
                      container.add(newTile);
                      // Update world data
                      world.types[x][y][z] = world.getBlockType(x,y,z);
                    }
                  }
                }
              }
            }

            function onDocumentMouseMove(event) {
              event.preventDefault();
              mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
              render();
              updateTarget();
            }

            function onDocumentMouseDown(event) {
              event.preventDefault();
      				mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
              var intersects = raycaster.intersectObjects(voxels);
              if(intersects.length > 0)
              {
                var intersect = intersects[0];
                var pos = intersect.object.position.clone();
                var nor = intersect.face.normal;

                var voxel = new THREE.Mesh(gridGeo, gridMat);
                // Find maximum component of face normal
                var maxComp = getMaxComp(nor);

                if(isShiftDown){
                  container.remove(container.getObjectByName(pos.toArray().toString().concat("t")));
                  container.remove(container.getObjectByName(pos.toArray().toString()));
                  world.grid[pos.x][pos.y][pos.z] = 0;
                  voxels.splice(voxels.indexOf(intersect.object), 1);
                  updateNeighbors(pos);
                }
                else {
                  var placed = false;
                  var tile;
                  // Update world.grid if click is within world bounds
                  switch(maxComp) {
                    case 0:
                      if(pos.x + nor.x < dim.x && pos.x + nor.x >= 0) {
                        placed = true;
                      }
                      break;
                    case 1:
                      if(pos.y < 0 && nor.y > 0) { // Place block on ground
                        pos.y -= 0.25;
                        placed = true;
                      }
                      else if (pos.y + nor.y < dim.y && pos.y + nor.y >= 0) {
                        placed = true;
                      }
                      break;
                    case 2:
                      if(pos.z + nor.z < dim.z && pos.z + nor.z >= 0) {
                        placed = true;
                      }
                      break;
                  }
                  if(placed) {
                    var tilePos = new THREE.Vector3(pos.x + nor.x, pos.y + nor.y, pos.z + nor.z);
                    var tileType = world.getBlockType(tilePos.x, tilePos.y, tilePos.z);
                    // Update world data
                    world.grid[tilePos.x][tilePos.y][tilePos.z] = 1;
                    world.types[tilePos.x][tilePos.y][tilePos.z] = tileType;
                    // Place voxel
                    voxel.position.copy(pos).add(nor);
                    voxel.name = tilePos.toArray().toString();
                    container.add(voxel);
                    voxels.push(voxel);
                    // Place tile
                    tile = tiles[tileType].clone();
                    tile.position.copy(tilePos);
                    tile.name = tilePos.toArray().toString().concat("t");
                    container.add(tile);

                    updateNeighbors(tilePos);
                  }
                }
              }
              render();
              updateTarget();
            }

            function onDocumentKeyDown(event) {
              switch( event.keyCode ) {
                case 16: isShiftDown = true;
                break;
              }
            }

            function onDocumentKeyUp(event) {
              switch ( event.keyCode ) {
                case 16: isShiftDown = false;
                break;
              }
            }

            // Helper function for dealing with surface normals
            function getMaxComp(vec3) {
              var absVec = new THREE.Vector3(Math.abs(vec3.x), Math.abs(vec3.y), Math.abs(vec3.z));
              if(absVec.x > absVec.y && absVec.x > absVec.z) {
                  return 0;
                }
                else if(absVec.y > absVec.x && absVec.y > absVec.z) {
                  return 1;
                }
                return 2;
            }

            // Updates the location of the target square
            function updateTarget() {
              raycaster.setFromCamera(mouse, camera);
              var intersects = raycaster.intersectObjects(voxels);
              if (intersects.length > 0) {
                targetMesh.visible = true;
                var intersect = intersects[0];
                var pos = intersect.object.position;
                var nor = intersect.face.normal;
                targetMesh.position.copy(pos);
                var maxComp = getMaxComp(nor);

                // Check if selection is on the ground
                if(pos.y < 0) {
                  if(nor.y <= 0) {
                    targetMesh.visible = false;
                  }
                  targetMesh.rotation.set(Math.PI/2, 0, 0);
                  targetMesh.position.y += nor.y / 3.999;
                  return;
                }

                switch(maxComp) {
                  case 0:
                    targetMesh.rotation.set(0, Math.PI/2, 0);
                    targetMesh.position.x += nor.x / 1.999;
                    break;
                  case 1:
                    targetMesh.rotation.set(Math.PI/2, 0, 0);
                    targetMesh.position.y += nor.y / 1.999;
                    break;
                  case 2:
                    targetMesh.rotation.set(0, 0, Math.PI/2);
                    targetMesh.position.z += nor.z / 1.999;
                    break;
                }
              }
              else {
                targetMesh.visible = false;
              }
            }

            function render() {
				      renderer.render( scene, camera );
            }

            function animate() {
              requestAnimationFrame(animate);
              render();
            }

            animate();
            controls.update();
          </script>
        </body>
</html>