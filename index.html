<html>
        <head>
          <meta charset=utf-8>
          <title>mapgen</title>
          <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
          </style>
        </head>
        <body>
          <script src="js/build/three.js"></script>
          <script src="js/controls/OrbitControls.js"></script>
          <script src="js/src/WorldGrid.js"></script>
          <script>
            var WIDTH = window.innerWidth,
                HEIGHT = window.innerHeight;

            var raycaster;
            var mouse = new THREE.Vector2();

            raycaster = new THREE.Raycaster();
            document.addEventListener('mousemove', function(event) {
              event.preventDefault();
				      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            }, false);
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );

            // Create a renderer and add it to the DOM.
            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setSize(WIDTH, HEIGHT);
            document.body.appendChild(renderer.domElement);

            var scene = new THREE.Scene();
            var blocks = [];
            var viewSize = 12;
            var aspectRatio = WIDTH / HEIGHT;
            var camera = new THREE.OrthographicCamera(-aspectRatio * viewSize / 2, aspectRatio * viewSize / 2, viewSize / 2, -viewSize / 2, -600, 600);
            //var camera = new THREE.PerspectiveCamera(104, WIDTH/HEIGHT);
            scene.add(camera);
            camera.position.set(3, 2, -1);

            var controls = new THREE.OrbitControls(camera);

            // Create an event listener that resizes the renderer with the browser window.
            window.addEventListener('resize', function() {
              var WIDTH = window.innerWidth,
                  HEIGHT = window.innerHeight,
                  aspectRatio = WIDTH / HEIGHT;

              renderer.setSize(WIDTH, HEIGHT);
              camera.left = -aspectRatio * viewSize / 2;
              camera.right = aspectRatio * viewSize / 2;
              camera.top = viewSize / 2;
              camera.bottom = -viewSize / 2;
              camera.updateProjectionMatrix();
            });

            // Set the background color of the scene.
            var clearColor = new THREE.Color(0x6084fa);
            renderer.setClearColor(clearColor, 1);

            // Draw from world
            var dim = new THREE.Vector3(3, 2, 4),
                world = new WorldGrid( dim.x, dim.y, dim.z );
            var lambertGreen = new THREE.MeshLambertMaterial( { color: 0xaaddaa, vertexColors: THREE.FaceColors } ),
                lambertGray = new THREE.MeshLambertMaterial( { color: 0x848484 } );
            var geometry = new THREE.BoxGeometry(1, 1, 1);

            for(var x = 0; x < world.x; x++) {
              for(var y = 0; y < world.y; y++) {
                for(var z = 0; z < world.z; z++) {
                    if(world.grid[x][y][z] == 1) {
                      var cube = new THREE.Mesh(geometry, lambertGreen);
                      cube.position.set(x - (dim.x - 1) / 2, y - (dim.y - 1) / 2, z - (dim.z - 1) / 2);
                      cube.name = x+""+y+""+z;

                      cube.material.vertexColors = THREE.FaceColors;
                      cube.geometry.faces[0].color.setRGB(1, 0, 0);
                      cube.geometry.faces[1].color.setRGB(1, 0, 0);
                      cube.geometry.faces[2].color.setRGB(0, 0, 1)
                      cube.geometry.faces[3].color.setRGB(0, 0, 1);
                      // cube.geometry.faces[4].color.setRGB(1, 0, 1);
                      // cube.geometry.faces[5].color.setRGB(0, 1, 1);
                      // cube.geometry.faces[6].color.setRGB(1, 1, 1);
                      // cube.geometry.faces[7].color.setRGB(.2, .7, 0);
                      // cube.geometry.faces[8].color.setRGB(0, 1, 1);
                      // cube.geometry.faces[9].color.setRGB(0, 1, 1);
                      // cube.geometry.faces[10].color.setRGB(0, 1, 1);
                      // cube.geometry.faces[11].color.setRGB(0, 1, 1);
                      // for(var i = 0 ; i < cube.geometry.faces.length; i++){
                      //   var face = cube.geometry.faces[i];
                      //   face.color.setRGB(1 / i, 1 / i, 1 / i);
                      // }

                      cube.geometry.elementsNeedUpdate = true;

                      scene.add(cube);
                      blocks.push(cube);
                    }
                }
              }
            }
            for(var x = 0; x < world.x; x++) {
              for(var z = 0; z < world.z; z++) {
                  var ground = new THREE.Mesh(geometry, lambertGray);
                  ground.scale.y = .5;
                  ground.position.set(x - (dim.x - 1) / 2, -1.25, z - (dim.z - 1) / 2);
                  scene.add(ground);
              }
            }

            // Create a light, set its position, and add it to the scene.
            var light = new THREE.PointLight(0xffffff);
            light.position.set(12,20,8);
            scene.add(light);
            var ambient = new THREE.AmbientLight( 0x0a84ff, 0.5 );
				    scene.add(ambient);

            renderer.render(scene,camera);
            controls.update();

            var animate = function() {
              requestAnimationFrame(animate);
              render();
            }

            function render() {
				      renderer.render( scene, camera );
            }

            function onDocumentMouseDown( event ) {
              event.preventDefault();
      				mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1 );
              raycaster.setFromCamera( mouse, camera );
              var intersects = raycaster.intersectObjects(blocks);
              if(intersects.length > 0)
              {
                var intersect = intersects[0];
                var worldPos = intersect.object.position;
                var gridPos = new THREE.Vector3(worldPos.x+(dim.x-1)/2,worldPos.y+(dim.y-1)/2,worldPos.z+(dim.z-1)/2);
                gridPos.sub(new THREE.Vector3(1,1,1));
                var nor = intersect.face.normal.normalize();

                var voxel = new THREE.Mesh(geometry, lambertGreen);
                voxel.position.copy(worldPos).add(nor);

                // Find maximum component of face normal
                var maxComp;
                if(nor.x > nor.y && nor.x > nor.z) maxComp = 0;
                else if(nor.y > nor.x && nor.y > nor.z) maxComp = 1;
                else maxComp = 2;
                // Update world.grid if click is within world bounds
                switch(maxComp) {
                  case 0:
                    if(gridPos.x + nor.x <= dim.x && gridPos.x + nor.x > 0) {
                      world.grid[gridPos.x+nor.x][gridPos.y][gridPos.z] = 1;
                    }
                    break;
                  case 1:
                    if(gridPos.y + nor.y <= dim.y && gridPos.y + nor.y > 0) {
                      world.grid[gridPos.x][gridPos.y+nor.y][gridPos.z] = 1;
                    }
                    break;
                  case 2:
                    if(gridPos.z + nor.z <= dim.z && gridPos.z + nor.z > 0) {
                      world.grid[gridPos.x][gridPos.y][gridPos.z+nor.z] = 1;
                    }
                    break;
                }
                scene.add( voxel );
                blocks.push( voxel );
              }
              render();
            }

           animate();
          </script>
        </body>
</html>